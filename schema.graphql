enum GovProposalVoteOption {
  EMPTY,
  YES,
  ABSTAIN,
  NO,
  NO_WITH_VETO,
}

enum TxStatus {
  Success
  Error
}

type EventAttribute @jsonField {
  key: String!
  value: String!
}

type Block @entity {
  id: ID! # The block header hash
  chainId: String! @index
  height: BigInt! @index
  timestamp: Date!
  transactions: [Transaction] @derivedFrom(field: "block")
  messages: [Message] @derivedFrom(field: "block")
  events: [Event] @derivedFrom(field: "block")
}

type Transaction @entity {
  id: ID!
  block: Block!
  gasUsed: BigInt!
  gasWanted: BigInt!
  fees: String!
  memo: String
  status: TxStatus!
  log: String!
  timeoutHeight: BigInt @index
  messages: [Message] @derivedFrom(field: "transaction")
}

type Message @entity {
  id: ID!
  typeUrl: String! @index
  json: String!
  transaction: Transaction!
  block: Block!
}

type Event @entity {
  id: ID!
  type: String! @index
  attributes: [EventAttribute]!
  log: String!
  transaction: Transaction!
  block: Block!
}

type ExecuteContractMessage @entity {
  id: ID!
  timestamp: String! @index
  from: String! @index
  to: String @index
  blockHeight: Int! @index
  txIndex: Int!
  msgIndex: Int!
  method: String! @index
  payload: String! # json payload for the contract
  funds: [Coin!]
}

type GovProposalVote @entity {
  id: ID!
  proposalId: String! @index
  voterAddress: String! @index
  option: GovProposalVoteOption!
  message: Message!
  transaction: Transaction!
  block: Block!
  #  TODO:
  #  weightedOptions: []
}

type DistDelegatorClaim @entity {
  id: ID!
  delegatorAddress: String!
  validatorAddress: String!
  message: Message!
  transaction: Transaction!
  block: Block!
  # TODO:
  #  validator: Validator!
  # TODO: introduced in cosmos-sdk (baseline) v0.46
  #  amount: BigInt!
  #  denom: String!
}

type LegacyBridgeSwap @entity {
  id: ID! # id field is always required and must look like this
  destination: String!
  amount: BigInt!
  denom: String!
  message: Message!
  transaction: Transaction!
  block: Block!
}

type Coin @jsonField {
  denom: String!
  amount: String!
}

type NativeTransferMsg @jsonField {
  toAddress: String! @index
  fromAddress: String! @index
  amount: [Coin]! @index
}

type NativeTransfer @entity {
  id: ID!
  toAddress: String! @index
  fromAddress: String! @index
  amounts: [Coin]!
  denom: String! @index
  transaction: Transaction!
  block: Block!
}
